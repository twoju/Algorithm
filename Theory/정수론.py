"""정수론

1. 소수 판정 * 1일때는 조심*
N = 12 라고 하면
1, 2, 3, 4, 6, 12 가 약수
그러면
1, 12
2, 6
3, 4 가 약수인데
왼쪽에는 루트N  보다 커질 수 가 없음 
-> (int(n** 0.5)) 이렇게 쓰면 루트임 
그러니까 소수 판정할 때는
2부터 루트 N 까지 찾았을 때 나눠 떨어지는 수가 없으면
소수이다

2. 약수 구하기
제곱수 빼고는 모두 약수가 짝으로 존재하기 때문에
제곱수이다 == 약수의 개수가 홀수다

3. 소인수분해 n = a * b * c * d
-> 루트 N 보다 큰 소인수는 0개 또는 1개이다.
(루트 N 보다 큰 수를 두 개 곱하면 N보다 커지니까)
-> 그래서 루트 N 까지만 완탐하고 남은 수가 1이 아니면 포함해주면 된다
# 보석도둑

4. 최대공약수, 최소공배수
- 최대공약수
a = 12, b = 18 일 때
a와 b의 최대공약수는, a와 (b-a) 의 최대 공약수와 같다
= a % b, b의 최대 공약수와도 같다 (계속 빼면 결국 나누기니까)

- 최소공배수
a와 b의 최대공약수가 12라면
: a * b / 12 가 최소공배수임 -> a / 12 * b로 계산하면 더 빠름

5. 에라토스테네스의 체
1 ~ N 까지 중에 어떤 것이 소수인지 알고싶을 때
* 두 가지만 기억하자*
1. 모든 수가 소수다
2. 1은 소수가 아니다
-> 1 지우고, 2는 소수니까 2의 배수 다 지우기, 3은 소수니까 3의 배수 다 지우기, 5는 소수니까 5의 배수 다 지우기 etc 반복
-> 코드에서는 숫자 : true 리스트를 만들어서 소수가 아닌 지우는 것을 false 로 바꾸는 방법으로 구현한다
-> i * i <= N 까지(루트 N)만 검증하면 된다

6. N // x
= 1부터 N까지 x의 배수가 몇개 있는가?

7. N! 에서 x의 배수의 개수
20! 에 2의 배수가 몇개 있는가?
-> N // x + N // (x * x)  + N // (x * x * x) … 등등 의 형식

8. n C m 오차 없이 구하기
10 C 3 = 10 * 9 * 8 / 3 * 2 * 1
-> 연속된 x개의 수에는 x의 배수가 정확히 하나 존재함
ex. 30 C 15 라고 한다면
30 / 1 * 29 / 2 * 28 / 3 * 27 / 4 … 이런 식으로 계산하면 오버플로우 없이 계산 가능
"""